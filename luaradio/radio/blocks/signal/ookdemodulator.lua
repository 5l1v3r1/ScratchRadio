---
-- Implements a simple On/Off Keying demodulator, where the input is a sequence
-- of samples modulated using OOK at an arbitrary IF and the output is a bipolar
-- representation generated by taking a windowed average of the absolute values
-- of the input signal and then applying DC offset cancellation. This output is
-- suitable for use with a simple zero crossing detector for timing recovery.
-- The window size and DC cancellation coefficients are derived from the nominal
-- ratio of sample rate to symbol rate.
--
-- @category Demodulator
-- @block OokDemodulatorBlock
-- @tparam number baudrate Baudrate in symbols per second
-- @tparam[opt=false] bool saturate Saturates output to +-1
--
-- @signature in:ComplexFloat32 > out:Float32
-- @signature in:Float32 > out:Float32
--
-- @usage
-- local demodulator = radio.OokDemodulatorBlock(baudrate, saturate)

local block = require('radio.core.block')
local types = require('radio.types')

local OokDemodulatorBlock = block.factory("OokDemodulatorBlock")

function OokDemodulatorBlock:instantiate(baudrate, saturate)
    self.baudrate = assert(baudrate, "Missing argument #1 (baudrate)")
    self.saturate = saturate

    self:add_type_signature({block.Input("in", types.ComplexFloat32)},
        {block.Output("out", types.Float32)}, self.process_complex, self.initialize_complex)
    self:add_type_signature({block.Input("in", types.Float32)},
        {block.Output("out", types.Float32)}, self.process_real, self.initialize_real)
end

function OokDemodulatorBlock:initialize_common()
    oversamplingFactor = self:get_rate() / self.baudrate
    print ("Demodulator oversampling factor " .. self:get_rate() .. "/" .. self.baudrate)
    if (oversamplingFactor < 4) then
        error ("Invalid oversampling factor " .. self:get_rate() .. "/" .. self.baudrate)
    end

    -- Derive the moving average window size and DC offset time constant from
    -- the ratio of sample rate to baudrate.
    self.bitWindowSize = math.ceil(7 * oversamplingFactor / 8)
    self.dcoWindowSize = 24 * self.bitWindowSize
    print ("Bit Window Size: ", self.bitWindowSize)
    print ("DC Offset Window Size: ", self.dcoWindowSize)

    -- Initialise the moving average filter and DC offset compensation values.
    self.bitWindowAccVal = 0
    self.bitWindowVals = {}
    for i = 1, self.bitWindowSize do
        self.bitWindowVals[i] = 0
    end
    self.bitWindowIndex = 1

    self.dcoWindowAccVal = 0
    self.dcoWindowVals = {}
    for i = 1, self.dcoWindowSize do
        self.dcoWindowVals[i] = 0
    end
    self.dcoWindowIndex = 1

    self.out = types.Float32.vector()
end

function OokDemodulatorBlock:initialize_complex()
    self:initialize_common()
end

function OokDemodulatorBlock:initialize_real()
    self.complexIn = types.ComplexFloat32.vector()
    self:initialize_common()
end

function OokDemodulatorBlock:process_common(x)
    local out = self.out:resize(x.length)

    for i = 0, x.length-1 do
        local thisReal = x.data[i].real
        local thisImag = x.data[i].imag
        local absSample = math.sqrt(thisReal * thisReal + thisImag * thisImag)

        -- Implements bit based moving average filter
        local bitDelaySample = self.bitWindowVals[self.bitWindowIndex]
        local bitAccVal = self.bitWindowAccVal + absSample - bitDelaySample
        self.bitWindowAccVal = bitAccVal
        self.bitWindowVals[self.bitWindowIndex] = absSample
        if (self.bitWindowIndex == self.bitWindowSize) then
            self.bitWindowIndex = 1
        else
            self.bitWindowIndex = self.bitWindowIndex + 1
        end

        -- Implements DC offset moving average filter on delayed sample
        local dcoDelaySample = self.dcoWindowVals[self.dcoWindowIndex]
        local dcoAccVal = self.dcoWindowAccVal + bitDelaySample - dcoDelaySample
        self.dcoWindowAccVal = dcoAccVal
        self.dcoWindowVals[self.dcoWindowIndex] = bitDelaySample
        if (self.dcoWindowIndex == self.dcoWindowSize) then
            self.dcoWindowIndex = 1
        else
            self.dcoWindowIndex = self.dcoWindowIndex + 1
        end

        -- Apply DC offset to windowed value
        local outVal = bitAccVal / self.bitWindowSize - dcoAccVal / self.dcoWindowSize
        if (self.saturate == true) then
            if (outVal > 0) then
                outVal = 1
            else
                outVal = -1
            end
        end
        out.data[i] = types.Float32(outVal)
    end

    return out
end

function OokDemodulatorBlock:process_complex(x)
    return self:process_common(x)
end

function OokDemodulatorBlock:process_real(x)
    local complexIn = self.complexIn:resize(x.length)
    for i = 0, x.length-1 do
        complexIn.data[i].real = x.data[i].value
        complexIn.data[i].imag = 0
    end
    return self:process_common(complexIn)
end

return OokDemodulatorBlock
